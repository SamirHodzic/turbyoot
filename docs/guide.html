<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Guide - Turbyoot</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
  <script>
    (function() {
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = savedTheme || (prefersDark ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
</head>
<body>
  <nav class="navbar">
    <div class="nav-container">
      <button class="mobile-menu-toggle" aria-label="Toggle menu">â˜°</button>
      <a href="index.html" class="nav-logo">Turbyoot</a>
      <div class="search-container">
        <input type="text" id="search-input" class="search-input" placeholder="Search documentation..." autocomplete="off">
        <div id="search-results" class="search-results"></div>
      </div>
      <ul class="nav-menu">
        <li><a href="index.html">Home</a></li>
        <li><a href="getting-started.html">Getting Started</a></li>
        <li><a href="guide.html" class="active">Guide</a></li>
        <li><a href="api.html">API Reference</a></li>
        <li><a href="https://github.com/SamirHodzic/turbyoot" target="_blank" rel="noopener noreferrer" class="external-link">GitHub <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
        <li>
          <button class="theme-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
            <svg class="theme-icon-light" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            <svg class="theme-icon-dark" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
          </button>
        </li>
      </ul>
    </div>
  </nav>

  <div class="container">
    <div class="sidebar">
      <nav class="sidebar-nav">
        <h3>Guide</h3>
        <ul>
          <li><a href="#routing">Routing</a></li>
          <li><a href="#basic-routing">Basic Routing</a></li>
          <li><a href="#fluent-api">Fluent API</a></li>
          <li><a href="#resource-routing">Resource Routing</a></li>
          <li><a href="#grouped-routes">Grouped Routes</a></li>
          <li><a href="#middleware">Middleware</a></li>
          <li><a href="#using-middleware">Using Middleware</a></li>
          <li><a href="#writing-middleware">Writing Middleware</a></li>
          <li><a href="#context">Context</a></li>
          <li><a href="#plugins">Plugins</a></li>
          <li><a href="#security">Security</a></li>
          <li><a href="#https-http2">HTTPS & HTTP/2</a></li>
        </ul>
      </nav>
    </div>

    <main class="content">
      <h1>Guide</h1>

      <section id="routing">
        <h2>Routing</h2>
        <p>Routing is one of the core features of Turbyoot. It allows you to define how your application responds to different HTTP requests.</p>
      </section>

      <section id="basic-routing">
        <h2>Basic Routing</h2>
        <p>Turbyoot supports all standard HTTP methods: GET, POST, PUT, DELETE, PATCH, OPTIONS, and HEAD.</p>
        <pre><code class="language-javascript">import { Turbyoot } from 'turbyoot';

const app = new Turbyoot();

app.get('/users', (ctx) => {
  ctx.ok({ users: [] });
});

app.post('/users', (ctx) => {
  ctx.created({ user: ctx.body });
});

app.put('/users/:id', (ctx) => {
  ctx.ok({ user: { id: ctx.params.id, ...ctx.body } });
});

app.del('/users/:id', (ctx) => {
  ctx.noContent();
});

app.patch('/users/:id', (ctx) => {
  ctx.ok({ user: { id: ctx.params.id, ...ctx.body } });
});</code></pre>
      </section>

      <section id="fluent-api">
        <h2>Fluent API</h2>
        <p>The fluent API provides a chainable syntax for defining routes with shared middleware:</p>
        <pre><code class="language-javascript">app.route()
  .use(authMiddleware)
  .get('/api/users', (ctx) => {
    ctx.ok({ users: [] });
  })
  .post('/api/users', (ctx) => {
    ctx.created({ user: ctx.body });
  })
  .get('/api/posts', (ctx) => {
    ctx.ok({ posts: [] });
  });</code></pre>
        <p>All routes defined in a fluent chain share the middleware applied with <code>.use()</code>.</p>
      </section>

      <section id="resource-routing">
        <h2>Resource Routing</h2>
        <p>Resource routing automatically generates CRUD routes for a resource. This is useful for RESTful APIs:</p>
        <pre><code class="language-javascript">app.resource('posts', {
  prefix: '/api',
  handlers: {
    index: (ctx) => ctx.ok({ posts: [] }),
    show: (ctx) => ctx.ok({ post: { id: ctx.params.id } }),
    create: (ctx) => ctx.created({ post: ctx.body }),
    update: (ctx) => ctx.ok({ post: { id: ctx.params.id, ...ctx.body } }),
    destroy: (ctx) => ctx.noContent()
  }
});</code></pre>
        <p>This creates the following routes:</p>
        <ul>
          <li><code>GET /api/posts</code> - index</li>
          <li><code>GET /api/posts/:id</code> - show</li>
          <li><code>POST /api/posts</code> - create</li>
          <li><code>PUT /api/posts/:id</code> - update</li>
          <li><code>DELETE /api/posts/:id</code> - destroy</li>
        </ul>
        <p>You can also filter which routes are created using <code>only</code> or <code>except</code>:</p>
        <pre><code class="language-javascript">app.resource('posts', {
  only: ['index', 'show'],
  handlers: {
    index: (ctx) => ctx.ok({ posts: [] }),
    show: (ctx) => ctx.ok({ post: { id: ctx.params.id } })
  }
});</code></pre>
      </section>

      <section id="grouped-routes">
        <h2>Grouped Routes</h2>
        <p>Group routes with a common prefix and shared middleware:</p>
        <pre><code class="language-javascript">app.group('/api/v1', (router) => {
  router
    .get('/users', (ctx) => ctx.ok({ users: [] }))
    .post('/users', (ctx) => ctx.created({ user: ctx.body }))
    .get('/posts', (ctx) => ctx.ok({ posts: [] }));
});</code></pre>
        <p>Groups can be nested:</p>
        <pre><code class="language-javascript">app.group('/api', (router) => {
  router.group('/v1', (v1Router) => {
    v1Router.get('/users', (ctx) => ctx.ok({ users: [] }));
  });
});</code></pre>
      </section>

      <section id="middleware">
        <h2>Middleware</h2>
        <p>Middleware functions are functions that have access to the context object and the next middleware function in the application's request-response cycle.</p>
      </section>

      <section id="using-middleware">
        <h2>Using Middleware</h2>
        <p>Use <code>app.use()</code> to apply middleware globally:</p>
        <pre><code class="language-javascript">import { cors, helmet, rateLimit } from 'turbyoot/middleware';

app.use(helmet());
app.use(cors({ origin: 'https://example.com' }));
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));</code></pre>
        <p>You can also apply middleware to specific routes:</p>
        <pre><code class="language-javascript">app.post('/users', validate({
  schema: {
    body: {
      name: { required: true, type: 'string' },
      email: { required: true, type: 'string' }
    }
  }
}), (ctx) => {
  ctx.created({ user: ctx.body });
});</code></pre>
      </section>

      <section id="writing-middleware">
        <h2>Writing Middleware</h2>
        <p>Middleware functions take two parameters: the context object and a next function. Call <code>next()</code> to pass control to the next middleware:</p>
        <pre><code class="language-javascript">const logger = async (ctx, next) => {
  console.log(`${ctx.req.method} ${ctx.req.url}`);
  await next();
  console.log(`Response: ${ctx.statusCode}`);
};

app.use(logger);</code></pre>
        <p>You can modify the context object to pass data to subsequent middleware and route handlers:</p>
        <pre><code class="language-javascript">const addTimestamp = async (ctx, next) => {
  ctx.state.timestamp = Date.now();
  await next();
};

app.use(addTimestamp);

app.get('/time', (ctx) => {
  ctx.ok({ timestamp: ctx.state.timestamp });
});</code></pre>
      </section>

      <section id="context">
        <h2>Context</h2>
        <p>The context object provides access to the request, response, and various helper methods:</p>
        <h3>Request Properties</h3>
        <ul>
          <li><code>ctx.req</code> - The Node.js HTTP request object</li>
          <li><code>ctx.params</code> - Route parameters</li>
          <li><code>ctx.query</code> - Query string parameters</li>
          <li><code>ctx.body</code> - Request body (parsed automatically)</li>
          <li><code>ctx.state</code> - State object for passing data between middleware</li>
        </ul>
        <h3>Response Methods</h3>
        <ul>
          <li><code>ctx.json(data)</code> - Send JSON response</li>
          <li><code>ctx.send(data)</code> - Send response (auto-detects type)</li>
          <li><code>ctx.status(code)</code> - Set status code</li>
          <li><code>ctx.ok(data)</code> - 200 OK</li>
          <li><code>ctx.created(data)</code> - 201 Created</li>
          <li><code>ctx.noContent()</code> - 204 No Content</li>
          <li><code>ctx.badRequest(message)</code> - 400 Bad Request</li>
          <li><code>ctx.unauthorized(message)</code> - 401 Unauthorized</li>
          <li><code>ctx.forbidden(message)</code> - 403 Forbidden</li>
          <li><code>ctx.notFound(message)</code> - 404 Not Found</li>
          <li><code>ctx.internalError(message)</code> - 500 Internal Server Error</li>
        </ul>
      </section>

      <section id="plugins">
        <h2>Plugins</h2>
        <p>Turbyoot supports a plugin system for extending functionality. Plugins allow you to modularize your application, create reusable functionality, and organize related features. Plugins are installed immediately when registered and have full access to the application instance.</p>
        
        <h3>Basic Plugin</h3>
        <p>The simplest plugin adds middleware or routes:</p>
        <pre><code class="language-javascript">const myPlugin = {
  name: 'my-plugin',
  version: '1.0.0',
  install(app) {
    app.use(async (ctx, next) => {
      console.log('Plugin middleware');
      await next();
    });
  }
};

app.plugin(myPlugin);</code></pre>

        <h3>Plugin with Routes</h3>
        <p>Plugins can add routes, including grouped routes:</p>
        <pre><code class="language-javascript">app.plugin({
  name: 'api-plugin',
  version: '1.0.0',
  install(app) {
    app.group('/api', (router) => {
      router.get('/users', (ctx) => ctx.ok({ users: [] }));
      router.post('/users', (ctx) => ctx.created({ user: ctx.body }));
    });
  }
});</code></pre>

        <h3>Configurable Plugins</h3>
        <p>Create plugin factories for configurable plugins:</p>
        <pre><code class="language-javascript">function createAuthPlugin(options) {
  return {
    name: 'auth-plugin',
    version: '1.0.0',
    install(app) {
      app.use(auth({
        cookieName: options.cookieName || 'auth-token',
        userResolver: options.userResolver
      }));
      
      app.get('/login', (ctx) => {
        // Login logic
      });
      
      app.post('/logout', (ctx) => {
        clearAuthCookie(ctx, options);
        ctx.ok({ message: 'Logged out' });
      });
    }
  };
}

app.plugin(createAuthPlugin({
  cookieName: 'session',
  userResolver: async (token) => {
    // Resolve user from token
    return user;
  }
}));</code></pre>

        <h3>Async Plugins</h3>
        <p>Plugins can be async, useful for initializing connections or loading configuration:</p>
        <pre><code class="language-javascript">app.plugin({
  name: 'database-plugin',
  version: '1.0.0',
  async install(app) {
    const db = await connectToDatabase(process.env.DATABASE_URL);
    
    app.use(async (ctx, next) => {
      ctx.state.db = db;
      await next();
    });
    
    app.get('/health', async (ctx) => {
      const isHealthy = await ctx.state.db.ping();
      ctx.ok({ database: isHealthy ? 'healthy' : 'unhealthy' });
    });
  }
});</code></pre>

        <h3>Plugin Best Practices</h3>
        <ul>
          <li><strong>Organization:</strong> Use plugins to group related functionality (authentication, database, API routes, etc.)</li>
          <li><strong>Reusability:</strong> Create plugin factories for functionality you want to reuse across projects</li>
          <li><strong>Initialization:</strong> Use async plugins for database connections, external service setup, etc.</li>
          <li><strong>Order Matters:</strong> Plugins are installed in registration order, so register dependencies first</li>
          <li><strong>Naming:</strong> Use descriptive names and include version numbers for plugin management</li>
        </ul>

        <h3>Plugin Use Cases</h3>
        <ul>
          <li>Adding authentication middleware and routes</li>
          <li>Setting up database connections and models</li>
          <li>Registering API route groups</li>
          <li>Adding logging, monitoring, or analytics</li>
          <li>Integrating third-party services</li>
          <li>Creating modular application features</li>
        </ul>
      </section>

      <section id="security">
        <h2>Security</h2>
        <p>Turbyoot includes built-in security features to help protect your application from common web vulnerabilities.</p>

        <h3>Input Sanitization</h3>
        <p>Turbyoot automatically sanitizes all request body and query parameters to prevent XSS (Cross-Site Scripting) and injection attacks. This sanitization happens automatically for all incoming requests, so you don't need to configure anything.</p>
        
        <p>The framework removes or neutralizes potentially dangerous content including:</p>
        <ul>
          <li>Script tags (<code>&lt;script&gt;</code>)</li>
          <li>Iframe tags (<code>&lt;iframe&gt;</code>)</li>
          <li>Object and embed tags</li>
          <li>Event handlers (onclick, onerror, etc.)</li>
          <li>JavaScript protocol URLs (<code>javascript:</code>)</li>
          <li>Data URI HTML content (<code>data:text/html</code>)</li>
        </ul>

        <h4>Body Sanitization</h4>
        <p>All request bodies (POST, PUT, PATCH) are automatically sanitized:</p>
        <pre><code class="language-javascript">app.post('/users', (ctx) => {
  // ctx.body is already sanitized
  // Malicious content like &lt;script&gt; tags are removed
  const user = ctx.body;
  ctx.created({ user });
});</code></pre>

        <h4>Query Parameter Sanitization</h4>
        <p>All query parameters are automatically sanitized:</p>
        <pre><code class="language-javascript">app.get('/search', (ctx) => {
  // ctx.query is already sanitized
  // Malicious content in query strings is removed
  const query = ctx.query.q;
  ctx.ok({ results: search(query) });
});</code></pre>

        <h4>What Gets Sanitized</h4>
        <p>The sanitization process:</p>
        <ul>
          <li>Works recursively on nested objects and arrays</li>
          <li>Preserves safe content (plain text, numbers, booleans)</li>
          <li>Removes dangerous HTML tags and attributes</li>
          <li>Handles deeply nested structures up to a configurable depth</li>
        </ul>

        <h3>Security Middleware</h3>
        <p>Turbyoot provides several security middleware functions to help protect your application. For complete API documentation, see the <a href="api.html#middleware">Middleware section in the API Reference</a>.</p>
        
        <p><strong>Available security middleware:</strong></p>
        <ul>
          <li><strong>helmet()</strong> - Sets HTTP security headers (CSP, X-Frame-Options, HSTS, etc.)</li>
          <li><strong>cors()</strong> - Configures Cross-Origin Resource Sharing</li>
          <li><strong>rateLimit()</strong> - Limits requests per IP to prevent abuse</li>
          <li><strong>csrf()</strong> - Protects against Cross-Site Request Forgery attacks</li>
        </ul>

        <p><strong>Basic setup:</strong></p>
        <pre><code class="language-javascript">import { helmet, cors, rateLimit, csrf } from 'turbyoot/middleware';

app.use(helmet());
app.use(cors({ origin: 'https://example.com' }));
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));
app.use(csrf());</code></pre>

        <p><strong>When to use CSRF protection:</strong></p>
        <ul>
          <li>Use when your app uses cookies for authentication</li>
          <li>Use for state-changing operations (POST, PUT, DELETE, PATCH)</li>
          <li>Skip for public APIs or token-based authentication (not cookies)</li>
          <li>Skip for webhook endpoints that receive requests from external services</li>
        </ul>

        <h3>Body Size Limits</h3>
        <p>Request bodies are limited to prevent DoS attacks. You can configure the limit using the <code>configure()</code> method:</p>
        <pre><code class="language-javascript">import { Turbyoot } from 'turbyoot';

const app = new Turbyoot();

app.configure({
  body: {
    limit: 2 * 1024 * 1024 // 2MB
  }
});</code></pre>
        <p>The default limit is 1MB. Requests exceeding the limit will receive a <code>413 Payload Too Large</code> response.</p>

        <h3>Security Best Practices</h3>
        <ul>
          <li><strong>Always use HTTPS in production:</strong> Encrypt all traffic to protect sensitive data</li>
          <li><strong>Use security middleware:</strong> Enable helmet() and configure CORS appropriately</li>
          <li><strong>Implement rate limiting:</strong> Protect your API from abuse and DDoS attacks</li>
          <li><strong>Validate input:</strong> While sanitization helps, always validate input data structure and types</li>
          <li><strong>Use parameterized queries:</strong> When using databases, always use parameterized queries to prevent SQL injection</li>
          <li><strong>Keep dependencies updated:</strong> Regularly update Turbyoot and other dependencies for security patches</li>
          <li><strong>Don't trust client data:</strong> Always validate and sanitize data from clients, even after sanitization</li>
        </ul>

        <p><strong>Note:</strong> While Turbyoot provides automatic sanitization and security middleware, security is a multi-layered approach. Always follow security best practices and perform regular security audits of your application.</p>
      </section>

      <section id="https-http2">
        <h2>HTTPS & HTTP/2</h2>
        <p>Turbyoot supports HTTP (default), HTTPS, and HTTP/2 protocols. You can configure the protocol and SSL/TLS options when starting the server.</p>

        <h3>HTTPS Server</h3>
        <p>To run your server with HTTPS, you need to provide SSL/TLS certificates. Here's how to set it up:</p>
        <pre><code class="language-javascript">import { readFileSync } from 'fs';
import { Turbyoot } from 'turbyoot';

const app = new Turbyoot();

app.get('/', (ctx) => {
  ctx.ok({ message: 'Hello from HTTPS!' });
});

const key = readFileSync('key.pem');
const cert = readFileSync('cert.pem');

app.listen(3443, {
  protocol: 'https',
  https: {
    key,
    cert,
  },
}, () => {
  console.log('HTTPS server is running on port 3443');
});</code></pre>

        <h3>Generating Self-Signed Certificates</h3>
        <p>For development, you can generate a self-signed certificate using OpenSSL:</p>
        <pre><code class="language-bash">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</code></pre>
        <p>This creates a certificate valid for 365 days. The <code>-nodes</code> flag creates a certificate without a passphrase.</p>

        <h3>HTTP/2 Server</h3>
        <p>HTTP/2 provides improved performance with features like multiplexing, header compression, and server push. Turbyoot supports both secure (with TLS) and insecure HTTP/2:</p>

        <h4>Secure HTTP/2</h4>
        <pre><code class="language-javascript">import { readFileSync } from 'fs';
import { Turbyoot } from 'turbyoot';

const app = new Turbyoot();

app.get('/', (ctx) => {
  ctx.ok({ message: 'Hello from HTTP/2!' });
});

const key = readFileSync('key.pem');
const cert = readFileSync('cert.pem');

app.listen(3444, {
  protocol: 'http2',
  https: {
    key,
    cert,
  },
  http2: {
    allowHTTP1: true,
    settings: {
      enablePush: true,
      initialWindowSize: 65535,
    },
  },
}, () => {
  console.log('HTTP/2 server is running on port 3444');
});</code></pre>

        <h4>Insecure HTTP/2 (Development Only)</h4>
        <pre><code class="language-javascript">app.listen(3444, {
  protocol: 'http2',
  http2: {
    allowHTTP1: true,
  },
}, () => {
  console.log('HTTP/2 server (insecure) is running');
});</code></pre>

        <h3>Server Options</h3>
        <p>The <code>listen()</code> method accepts several configuration options:</p>
        <ul>
          <li><code>protocol</code> - Protocol to use: <code>'http'</code>, <code>'https'</code>, or <code>'http2'</code></li>
          <li><code>https</code> - HTTPS/SSL configuration (required for HTTPS and secure HTTP/2)</li>
          <li><code>http2</code> - HTTP/2 specific options (settings, allowHTTP1, etc.)</li>
          <li><code>host</code> - Hostname to bind to (defaults to all interfaces)</li>
          <li><code>backlog</code> - Maximum length of the queue of pending connections</li>
        </ul>

        <h3>Production Considerations</h3>
        <ul>
          <li><strong>Certificates:</strong> Use valid SSL/TLS certificates from a trusted Certificate Authority (CA) in production</li>
          <li><strong>HTTP/2:</strong> Most browsers require TLS for HTTP/2, so use secure HTTP/2 in production</li>
          <li><strong>Performance:</strong> HTTP/2 can significantly improve performance for applications with many concurrent requests</li>
          <li><strong>Fallback:</strong> Enable <code>allowHTTP1: true</code> for HTTP/2 servers to support older clients</li>
        </ul>
      </section>
    </main>
  </div>

  <footer class="footer">
    <p>&copy; 2025 Turbyoot. MIT License.</p>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="script.js"></script>
</body>
</html>
